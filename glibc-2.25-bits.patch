--- glibc-2.25/bits/wordsize.h.bak	2018-11-08 15:12:14.756848932 +0200
+++ glibc-2.25/bits/wordsize.h	2018-11-08 15:13:00.505009458 +0200
@@ -1,27 +1,25 @@
-#error "This file must be written based on the data type sizes of the target"
-
 /* The following entries are a template for what defines should be in the
    wordsize.h header file for a target.  */
 
 /* Size in bits of the 'long int' and pointer types.  */
-#define __WORDSIZE
+#define __WORDSIZE 32
 
 /* This should be set to 1 if __WORDSIZE is 32 and size_t is type
    'unsigned long' instead of type 'unsigned int'.  This will ensure
    that SIZE_MAX is defined as an unsigned long constant instead of an
    unsigned int constant.  Set to 0 if __WORDSIZE is 32 and size_t is
    'unsigned int' and leave undefined if __WORDSIZE is 64.  */
-#define __WORDSIZE32_SIZE_ULONG
+#define __WORDSIZE32_SIZE_ULONG 0
 
 /* This should be set to 1 if __WORDSIZE is 32 and ptrdiff_t is type 'long'
    instead of type 'int'.  This will ensure that PTRDIFF_MIN and PTRDIFF_MAX
    are defined as long constants instead of int constants.  Set to 0 if
    __WORDSIZE is 32 and ptrdiff_t is type 'int' and leave undefined if
    __WORDSIZE is 64.  */
-#define __WORDSIZE32_PTRDIFF_LONG
+#define __WORDSIZE32_PTRDIFF_LONG 0
 
 /* Set to 1 in order to force time types to be 32 bits instead of 64 bits in
    struct lastlog and struct utmp{,x} on 64-bit ports.  This may be done in
    order to make 64-bit ports compatible with 32-bit ports.  Set to 0 for
    64-bit ports where the time types are 64-bits or for any 32-bit ports.  */
-#define __WORDSIZE_TIME64_COMPAT32
+#define __WORDSIZE_TIME64_COMPAT32 0
--- glibc-2.25/bits/errno.h.bak	2018-11-08 14:32:39.009340807 +0200
+++ glibc-2.25/bits/errno.h	2018-11-08 14:43:21.450954354 +0200
@@ -1,4 +1,5 @@
-/* Copyright (C) 1991-2017 Free Software Foundation, Inc.
+/* Error constants.  Linux specific version.
+   Copyright (C) 1996-2014 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -15,20 +16,51 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This file defines the `errno' constants.  */
+#ifdef _ERRNO_H
 
-#if !defined __Emath_defined && (defined _ERRNO_H || defined __need_Emath)
-#undef	__need_Emath
-#define	__Emath_defined	1
-
-# define EDOM	XXX	<--- fill in what is actually needed
-# define EILSEQ	XXX	<--- fill in what is actually needed
-# define ERANGE	XXX	<--- fill in what is actually needed
-#endif
-
-#ifdef	_ERRNO_H
-# error "Define here all the missing error messages for the port.  These"
-# error "must match the numbers of the kernel."
-# define Exxxx	XXX
-...
-#endif
+# undef EDOM
+# undef EILSEQ
+# undef ERANGE
+# include <linux/errno.h>
+
+/* Linux has no ENOTSUP error code.  */
+# define ENOTSUP EOPNOTSUPP
+
+/* Older Linux versions also had no ECANCELED error code.  */
+# ifndef ECANCELED
+#  define ECANCELED	125
+# endif
+
+/* Support for error codes to support robust mutexes was added later, too.  */
+# ifndef EOWNERDEAD
+#  define EOWNERDEAD		130
+#  define ENOTRECOVERABLE	131
+# endif
+
+# ifndef ERFKILL
+#  define ERFKILL		132
+# endif
+
+# ifndef EHWPOISON
+#  define EHWPOISON		133
+# endif
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+# define EDOM	33	/* Math argument out of domain of function.  */
+# define EILSEQ	84	/* Illegal byte sequence.  */
+# define ERANGE	34	/* Math result not representable.  */
+#endif /* !_ERRNO_H && __need_Emath */
--- glibc-2.25/bits/endian.h.bak	2018-11-08 15:51:55.110637120 +0200
+++ glibc-2.25/bits/endian.h	2018-11-08 15:52:20.538742585 +0200
@@ -1,13 +1,10 @@
-/* This file should define __BYTE_ORDER as appropriate for the machine
-   in question.  See string/endian.h for how to define it.
-
-   If only the stub bits/endian.h applies to a particular configuration,
-   bytesex.h is generated by running a program on the host machine.
-   So if cross-compiling to a machine with a different byte order,
-   the bits/endian.h file for that machine must exist.  */
-
 #ifndef _ENDIAN_H
 # error "Never use <bits/endian.h> directly; include <endian.h> instead."
 #endif
 
-#error Machine byte order unknown.
+/* ARM can be either big or little endian.  */
+#ifdef __ARMEB__
+#define __BYTE_ORDER __BIG_ENDIAN
+#else
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#endif
